// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
pub mod exports {
    pub mod midoku {
        pub mod midoku_types {
            #[allow(clippy::all)]
            pub mod chapter {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[doc(hidden)]

                macro_rules! __export_midoku_midoku_types_chapter_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_midoku_midoku_types_chapter_cabi;
            }

            #[allow(clippy::all)]
            pub mod manga {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum Status {
                    Unknown,
                    Ongoing,
                    Completed,
                    Hiatus,
                    Cancelled,
                }
                impl ::core::fmt::Debug for Status {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Status::Unknown => f.debug_tuple("Status::Unknown").finish(),
                            Status::Ongoing => f.debug_tuple("Status::Ongoing").finish(),
                            Status::Completed => f.debug_tuple("Status::Completed").finish(),
                            Status::Hiatus => f.debug_tuple("Status::Hiatus").finish(),
                            Status::Cancelled => f.debug_tuple("Status::Cancelled").finish(),
                        }
                    }
                }

                impl Status {
                    pub(crate) unsafe fn _lift(val: u8) -> Status {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => Status::Unknown,
                            1 => Status::Ongoing,
                            2 => Status::Completed,
                            3 => Status::Hiatus,
                            4 => Status::Cancelled,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum ContentRating {
                    Safe,
                    Suggestive,
                    Nsfw,
                }
                impl ::core::fmt::Debug for ContentRating {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            ContentRating::Safe => f.debug_tuple("ContentRating::Safe").finish(),
                            ContentRating::Suggestive => {
                                f.debug_tuple("ContentRating::Suggestive").finish()
                            }
                            ContentRating::Nsfw => f.debug_tuple("ContentRating::Nsfw").finish(),
                        }
                    }
                }

                impl ContentRating {
                    pub(crate) unsafe fn _lift(val: u8) -> ContentRating {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => ContentRating::Safe,
                            1 => ContentRating::Suggestive,
                            2 => ContentRating::Nsfw,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum ReadingMode {
                    RightToLeft,
                    LeftToRight,
                    Vertical,
                    Scroll,
                }
                impl ::core::fmt::Debug for ReadingMode {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            ReadingMode::RightToLeft => {
                                f.debug_tuple("ReadingMode::RightToLeft").finish()
                            }
                            ReadingMode::LeftToRight => {
                                f.debug_tuple("ReadingMode::LeftToRight").finish()
                            }
                            ReadingMode::Vertical => {
                                f.debug_tuple("ReadingMode::Vertical").finish()
                            }
                            ReadingMode::Scroll => f.debug_tuple("ReadingMode::Scroll").finish(),
                        }
                    }
                }

                impl ReadingMode {
                    pub(crate) unsafe fn _lift(val: u8) -> ReadingMode {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => ReadingMode::RightToLeft,
                            1 => ReadingMode::LeftToRight,
                            2 => ReadingMode::Vertical,
                            3 => ReadingMode::Scroll,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[doc(hidden)]

                macro_rules! __export_midoku_midoku_types_manga_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_midoku_midoku_types_manga_cabi;
            }

            #[allow(clippy::all)]
            pub mod page {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[doc(hidden)]

                macro_rules! __export_midoku_midoku_types_page_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_midoku_midoku_types_page_cabi;
            }
        }
    }
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_types_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::midoku::midoku_types::chapter::__export_midoku_midoku_types_chapter_cabi!($ty with_types_in $($path_to_types_root)*::exports::midoku::midoku_types::chapter);
  $($path_to_types_root)*::exports::midoku::midoku_types::manga::__export_midoku_midoku_types_manga_cabi!($ty with_types_in $($path_to_types_root)*::exports::midoku::midoku_types::manga);
  $($path_to_types_root)*::exports::midoku::midoku_types::page::__export_midoku_midoku_types_page_cabi!($ty with_types_in $($path_to_types_root)*::exports::midoku::midoku_types::page);
  )
}
#[doc(inline)]
pub(crate) use __export_types_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:types:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 715] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xcf\x04\x01A\x02\x01\
A\x06\x01B\x02\x01r\x08\x02ids\x05titles\x06volumev\x07chapterv\x0cdata-updatedy\
\x09scanlators\x03urls\x08languages\x04\0\x07chapter\x03\0\0\x04\x01\x1bmidoku:m\
idoku-types/chapter\x05\0\x01B\x0c\x01m\x05\x07unknown\x07ongoing\x09completed\x06\
hiatus\x09cancelled\x04\0\x06status\x03\0\0\x01m\x03\x04safe\x0asuggestive\x04ns\
fw\x04\0\x0econtent-rating\x03\0\x02\x01m\x04\x0dright-to-left\x0dleft-to-right\x08\
vertical\x06scroll\x04\0\x0creading-mode\x03\0\x04\x01ps\x01r\x0b\x02ids\x05titl\
es\x03urls\x0bdescriptions\x09cover-urls\x0bauthor-names\x0bartist-names\x0acate\
gories\x06\x06status\x01\x0econtent-rating\x03\x0creading-mode\x05\x04\0\x05mang\
a\x03\0\x07\x01p\x08\x01r\x02\x04page\x09\x08has-more\x7f\x04\0\x0bpage-result\x03\
\0\x0a\x04\x01\x19midoku:midoku-types/manga\x05\x01\x01B\x02\x01r\x03\x05indexy\x03\
urls\x05bas64s\x04\0\x04page\x03\0\0\x04\x01\x18midoku:midoku-types/page\x05\x02\
\x04\x01\x19midoku:midoku-types/types\x04\0\x0b\x0b\x01\0\x05types\x03\0\0\0G\x09\
producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.201.0\x10wit-bindgen-rus\
t\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
