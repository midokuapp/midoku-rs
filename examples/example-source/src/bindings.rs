// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
pub type Chapter = midoku::midoku_types::chapter::Chapter;
pub type Manga = midoku::midoku_types::manga::Manga;
pub type PageResult = midoku::midoku_types::manga::PageResult;
pub type Page = midoku::midoku_types::page::Page;
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_manga_list_cabi<T: Guest>(arg0: i32) -> *mut u8 {
    let result0 = T::get_manga_list(arg0 as u32);
    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result0 {
        Ok(e) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
            let midoku::midoku_types::manga::PageResult {
                page: page2,
                has_more: has_more2,
            } = e;
            let vec13 = page2;
            let len13 = vec13.len();
            let layout13 = _rt::alloc::Layout::from_size_align_unchecked(vec13.len() * 68, 4);
            let result13 = if layout13.size() != 0 {
                let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout13);
                }
                ptr
            } else {
                {
                    ::core::ptr::null_mut()
                }
            };
            for (i, e) in vec13.into_iter().enumerate() {
                let base = result13.add(i * 68);
                {
                    let midoku::midoku_types::manga::Manga {
                        id: id3,
                        title: title3,
                        url: url3,
                        description: description3,
                        cover_url: cover_url3,
                        author_name: author_name3,
                        artist_name: artist_name3,
                        categories: categories3,
                        status: status3,
                        content_rating: content_rating3,
                        reading_mode: reading_mode3,
                    } = e;
                    let vec4 = (id3.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *base.add(4).cast::<usize>() = len4;
                    *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (title3.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *base.add(12).cast::<usize>() = len5;
                    *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = (url3.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *base.add(20).cast::<usize>() = len6;
                    *base.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                    let vec7 = (description3.into_bytes()).into_boxed_slice();
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    ::core::mem::forget(vec7);
                    *base.add(28).cast::<usize>() = len7;
                    *base.add(24).cast::<*mut u8>() = ptr7.cast_mut();
                    let vec8 = (cover_url3.into_bytes()).into_boxed_slice();
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    ::core::mem::forget(vec8);
                    *base.add(36).cast::<usize>() = len8;
                    *base.add(32).cast::<*mut u8>() = ptr8.cast_mut();
                    let vec9 = (author_name3.into_bytes()).into_boxed_slice();
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    ::core::mem::forget(vec9);
                    *base.add(44).cast::<usize>() = len9;
                    *base.add(40).cast::<*mut u8>() = ptr9.cast_mut();
                    let vec10 = (artist_name3.into_bytes()).into_boxed_slice();
                    let ptr10 = vec10.as_ptr().cast::<u8>();
                    let len10 = vec10.len();
                    ::core::mem::forget(vec10);
                    *base.add(52).cast::<usize>() = len10;
                    *base.add(48).cast::<*mut u8>() = ptr10.cast_mut();
                    let vec12 = categories3;
                    let len12 = vec12.len();
                    let layout12 =
                        _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 8, 4);
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 8);
                        {
                            let vec11 = (e.into_bytes()).into_boxed_slice();
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            ::core::mem::forget(vec11);
                            *base.add(4).cast::<usize>() = len11;
                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                        }
                    }
                    *base.add(60).cast::<usize>() = len12;
                    *base.add(56).cast::<*mut u8>() = result12;
                    *base.add(64).cast::<u8>() = (status3.clone() as i32) as u8;
                    *base.add(65).cast::<u8>() = (content_rating3.clone() as i32) as u8;
                    *base.add(66).cast::<u8>() = (reading_mode3.clone() as i32) as u8;
                }
            }
            *ptr1.add(8).cast::<usize>() = len13;
            *ptr1.add(4).cast::<*mut u8>() = result13;
            *ptr1.add(12).cast::<u8>() = (match has_more2 {
                true => 1,
                false => 0,
            }) as u8;
        }
        Err(_) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_manga_list<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l20 = *arg0.add(4).cast::<*mut u8>();
            let l21 = *arg0.add(8).cast::<usize>();
            let base22 = l20;
            let len22 = l21;
            for i in 0..len22 {
                let base = base22.add(i * 68);
                {
                    let l1 = *base.add(0).cast::<*mut u8>();
                    let l2 = *base.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l1, l2, 1);
                    let l3 = *base.add(8).cast::<*mut u8>();
                    let l4 = *base.add(12).cast::<usize>();
                    _rt::cabi_dealloc(l3, l4, 1);
                    let l5 = *base.add(16).cast::<*mut u8>();
                    let l6 = *base.add(20).cast::<usize>();
                    _rt::cabi_dealloc(l5, l6, 1);
                    let l7 = *base.add(24).cast::<*mut u8>();
                    let l8 = *base.add(28).cast::<usize>();
                    _rt::cabi_dealloc(l7, l8, 1);
                    let l9 = *base.add(32).cast::<*mut u8>();
                    let l10 = *base.add(36).cast::<usize>();
                    _rt::cabi_dealloc(l9, l10, 1);
                    let l11 = *base.add(40).cast::<*mut u8>();
                    let l12 = *base.add(44).cast::<usize>();
                    _rt::cabi_dealloc(l11, l12, 1);
                    let l13 = *base.add(48).cast::<*mut u8>();
                    let l14 = *base.add(52).cast::<usize>();
                    _rt::cabi_dealloc(l13, l14, 1);
                    let l17 = *base.add(56).cast::<*mut u8>();
                    let l18 = *base.add(60).cast::<usize>();
                    let base19 = l17;
                    let len19 = l18;
                    for i in 0..len19 {
                        let base = base19.add(i * 8);
                        {
                            let l15 = *base.add(0).cast::<*mut u8>();
                            let l16 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l15, l16, 1);
                        }
                    }
                    _rt::cabi_dealloc(base19, len19 * 8, 4);
                }
            }
            _rt::cabi_dealloc(base22, len22 * 68, 4);
        }
        _ => (),
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_manga_details_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::get_manga_details(_rt::string_lift(bytes0));
    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result1 {
        Ok(e) => {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
            let midoku::midoku_types::manga::Manga {
                id: id3,
                title: title3,
                url: url3,
                description: description3,
                cover_url: cover_url3,
                author_name: author_name3,
                artist_name: artist_name3,
                categories: categories3,
                status: status3,
                content_rating: content_rating3,
                reading_mode: reading_mode3,
            } = e;
            let vec4 = (id3.into_bytes()).into_boxed_slice();
            let ptr4 = vec4.as_ptr().cast::<u8>();
            let len4 = vec4.len();
            ::core::mem::forget(vec4);
            *ptr2.add(8).cast::<usize>() = len4;
            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
            let vec5 = (title3.into_bytes()).into_boxed_slice();
            let ptr5 = vec5.as_ptr().cast::<u8>();
            let len5 = vec5.len();
            ::core::mem::forget(vec5);
            *ptr2.add(16).cast::<usize>() = len5;
            *ptr2.add(12).cast::<*mut u8>() = ptr5.cast_mut();
            let vec6 = (url3.into_bytes()).into_boxed_slice();
            let ptr6 = vec6.as_ptr().cast::<u8>();
            let len6 = vec6.len();
            ::core::mem::forget(vec6);
            *ptr2.add(24).cast::<usize>() = len6;
            *ptr2.add(20).cast::<*mut u8>() = ptr6.cast_mut();
            let vec7 = (description3.into_bytes()).into_boxed_slice();
            let ptr7 = vec7.as_ptr().cast::<u8>();
            let len7 = vec7.len();
            ::core::mem::forget(vec7);
            *ptr2.add(32).cast::<usize>() = len7;
            *ptr2.add(28).cast::<*mut u8>() = ptr7.cast_mut();
            let vec8 = (cover_url3.into_bytes()).into_boxed_slice();
            let ptr8 = vec8.as_ptr().cast::<u8>();
            let len8 = vec8.len();
            ::core::mem::forget(vec8);
            *ptr2.add(40).cast::<usize>() = len8;
            *ptr2.add(36).cast::<*mut u8>() = ptr8.cast_mut();
            let vec9 = (author_name3.into_bytes()).into_boxed_slice();
            let ptr9 = vec9.as_ptr().cast::<u8>();
            let len9 = vec9.len();
            ::core::mem::forget(vec9);
            *ptr2.add(48).cast::<usize>() = len9;
            *ptr2.add(44).cast::<*mut u8>() = ptr9.cast_mut();
            let vec10 = (artist_name3.into_bytes()).into_boxed_slice();
            let ptr10 = vec10.as_ptr().cast::<u8>();
            let len10 = vec10.len();
            ::core::mem::forget(vec10);
            *ptr2.add(56).cast::<usize>() = len10;
            *ptr2.add(52).cast::<*mut u8>() = ptr10.cast_mut();
            let vec12 = categories3;
            let len12 = vec12.len();
            let layout12 = _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 8, 4);
            let result12 = if layout12.size() != 0 {
                let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout12);
                }
                ptr
            } else {
                {
                    ::core::ptr::null_mut()
                }
            };
            for (i, e) in vec12.into_iter().enumerate() {
                let base = result12.add(i * 8);
                {
                    let vec11 = (e.into_bytes()).into_boxed_slice();
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    ::core::mem::forget(vec11);
                    *base.add(4).cast::<usize>() = len11;
                    *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                }
            }
            *ptr2.add(64).cast::<usize>() = len12;
            *ptr2.add(60).cast::<*mut u8>() = result12;
            *ptr2.add(68).cast::<u8>() = (status3.clone() as i32) as u8;
            *ptr2.add(69).cast::<u8>() = (content_rating3.clone() as i32) as u8;
            *ptr2.add(70).cast::<u8>() = (reading_mode3.clone() as i32) as u8;
        }
        Err(_) => {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
        }
    };
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_manga_details<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = *arg0.add(4).cast::<*mut u8>();
            let l2 = *arg0.add(8).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
            let l3 = *arg0.add(12).cast::<*mut u8>();
            let l4 = *arg0.add(16).cast::<usize>();
            _rt::cabi_dealloc(l3, l4, 1);
            let l5 = *arg0.add(20).cast::<*mut u8>();
            let l6 = *arg0.add(24).cast::<usize>();
            _rt::cabi_dealloc(l5, l6, 1);
            let l7 = *arg0.add(28).cast::<*mut u8>();
            let l8 = *arg0.add(32).cast::<usize>();
            _rt::cabi_dealloc(l7, l8, 1);
            let l9 = *arg0.add(36).cast::<*mut u8>();
            let l10 = *arg0.add(40).cast::<usize>();
            _rt::cabi_dealloc(l9, l10, 1);
            let l11 = *arg0.add(44).cast::<*mut u8>();
            let l12 = *arg0.add(48).cast::<usize>();
            _rt::cabi_dealloc(l11, l12, 1);
            let l13 = *arg0.add(52).cast::<*mut u8>();
            let l14 = *arg0.add(56).cast::<usize>();
            _rt::cabi_dealloc(l13, l14, 1);
            let l17 = *arg0.add(60).cast::<*mut u8>();
            let l18 = *arg0.add(64).cast::<usize>();
            let base19 = l17;
            let len19 = l18;
            for i in 0..len19 {
                let base = base19.add(i * 8);
                {
                    let l15 = *base.add(0).cast::<*mut u8>();
                    let l16 = *base.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l15, l16, 1);
                }
            }
            _rt::cabi_dealloc(base19, len19 * 8, 4);
        }
        _ => (),
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_chapter_list_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::get_chapter_list(_rt::string_lift(bytes0));
    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result1 {
        Ok(e) => {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
            let vec9 = e;
            let len9 = vec9.len();
            let layout9 = _rt::alloc::Layout::from_size_align_unchecked(vec9.len() * 52, 4);
            let result9 = if layout9.size() != 0 {
                let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout9);
                }
                ptr
            } else {
                {
                    ::core::ptr::null_mut()
                }
            };
            for (i, e) in vec9.into_iter().enumerate() {
                let base = result9.add(i * 52);
                {
                    let midoku::midoku_types::chapter::Chapter {
                        id: id3,
                        title: title3,
                        volume: volume3,
                        chapter: chapter3,
                        data_updated: data_updated3,
                        scanlator: scanlator3,
                        url: url3,
                        language: language3,
                    } = e;
                    let vec4 = (id3.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *base.add(4).cast::<usize>() = len4;
                    *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (title3.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *base.add(12).cast::<usize>() = len5;
                    *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                    *base.add(16).cast::<f32>() = _rt::as_f32(volume3);
                    *base.add(20).cast::<f32>() = _rt::as_f32(chapter3);
                    *base.add(24).cast::<i32>() = _rt::as_i32(data_updated3);
                    let vec6 = (scanlator3.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *base.add(32).cast::<usize>() = len6;
                    *base.add(28).cast::<*mut u8>() = ptr6.cast_mut();
                    let vec7 = (url3.into_bytes()).into_boxed_slice();
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    ::core::mem::forget(vec7);
                    *base.add(40).cast::<usize>() = len7;
                    *base.add(36).cast::<*mut u8>() = ptr7.cast_mut();
                    let vec8 = (language3.into_bytes()).into_boxed_slice();
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    ::core::mem::forget(vec8);
                    *base.add(48).cast::<usize>() = len8;
                    *base.add(44).cast::<*mut u8>() = ptr8.cast_mut();
                }
            }
            *ptr2.add(8).cast::<usize>() = len9;
            *ptr2.add(4).cast::<*mut u8>() = result9;
        }
        Err(_) => {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
        }
    };
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_chapter_list<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l11 = *arg0.add(4).cast::<*mut u8>();
            let l12 = *arg0.add(8).cast::<usize>();
            let base13 = l11;
            let len13 = l12;
            for i in 0..len13 {
                let base = base13.add(i * 52);
                {
                    let l1 = *base.add(0).cast::<*mut u8>();
                    let l2 = *base.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l1, l2, 1);
                    let l3 = *base.add(8).cast::<*mut u8>();
                    let l4 = *base.add(12).cast::<usize>();
                    _rt::cabi_dealloc(l3, l4, 1);
                    let l5 = *base.add(28).cast::<*mut u8>();
                    let l6 = *base.add(32).cast::<usize>();
                    _rt::cabi_dealloc(l5, l6, 1);
                    let l7 = *base.add(36).cast::<*mut u8>();
                    let l8 = *base.add(40).cast::<usize>();
                    _rt::cabi_dealloc(l7, l8, 1);
                    let l9 = *base.add(44).cast::<*mut u8>();
                    let l10 = *base.add(48).cast::<usize>();
                    _rt::cabi_dealloc(l9, l10, 1);
                }
            }
            _rt::cabi_dealloc(base13, len13 * 52, 4);
        }
        _ => (),
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_page_list_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
    arg2: *mut u8,
    arg3: usize,
) -> *mut u8 {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    let result2 = T::get_page_list(_rt::string_lift(bytes0), _rt::string_lift(bytes1));
    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result2 {
        Ok(e) => {
            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
            let vec7 = e;
            let len7 = vec7.len();
            let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 20, 4);
            let result7 = if layout7.size() != 0 {
                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout7);
                }
                ptr
            } else {
                {
                    ::core::ptr::null_mut()
                }
            };
            for (i, e) in vec7.into_iter().enumerate() {
                let base = result7.add(i * 20);
                {
                    let midoku::midoku_types::page::Page {
                        index: index4,
                        url: url4,
                        bas64: bas644,
                    } = e;
                    *base.add(0).cast::<i32>() = _rt::as_i32(index4);
                    let vec5 = (url4.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *base.add(8).cast::<usize>() = len5;
                    *base.add(4).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = (bas644.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *base.add(16).cast::<usize>() = len6;
                    *base.add(12).cast::<*mut u8>() = ptr6.cast_mut();
                }
            }
            *ptr3.add(8).cast::<usize>() = len7;
            *ptr3.add(4).cast::<*mut u8>() = result7;
        }
        Err(_) => {
            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
        }
    };
    ptr3
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_page_list<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l5 = *arg0.add(4).cast::<*mut u8>();
            let l6 = *arg0.add(8).cast::<usize>();
            let base7 = l5;
            let len7 = l6;
            for i in 0..len7 {
                let base = base7.add(i * 20);
                {
                    let l1 = *base.add(4).cast::<*mut u8>();
                    let l2 = *base.add(8).cast::<usize>();
                    _rt::cabi_dealloc(l1, l2, 1);
                    let l3 = *base.add(12).cast::<*mut u8>();
                    let l4 = *base.add(16).cast::<usize>();
                    _rt::cabi_dealloc(l3, l4, 1);
                }
            }
            _rt::cabi_dealloc(base7, len7 * 20, 4);
        }
        _ => (),
    }
}
pub trait Guest {
    fn get_manga_list(page: u32) -> Result<PageResult, ()>;
    fn get_manga_details(manga_id: _rt::String) -> Result<Manga, ()>;
    fn get_chapter_list(manga_id: _rt::String) -> Result<_rt::Vec<Chapter>, ()>;
    fn get_page_list(manga_id: _rt::String, chapter_id: _rt::String) -> Result<_rt::Vec<Page>, ()>;
}
#[doc(hidden)]

macro_rules! __export_world_prelude_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "get-manga-list"]
    unsafe extern "C" fn export_get_manga_list(arg0: i32,) -> *mut u8 {
      $($path_to_types)*::_export_get_manga_list_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_get-manga-list"]
    unsafe extern "C" fn _post_return_get_manga_list(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_manga_list::<$ty>(arg0)
    }
    #[export_name = "get-manga-details"]
    unsafe extern "C" fn export_get_manga_details(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_get_manga_details_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_get-manga-details"]
    unsafe extern "C" fn _post_return_get_manga_details(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_manga_details::<$ty>(arg0)
    }
    #[export_name = "get-chapter-list"]
    unsafe extern "C" fn export_get_chapter_list(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_get_chapter_list_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_get-chapter-list"]
    unsafe extern "C" fn _post_return_get_chapter_list(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_chapter_list::<$ty>(arg0)
    }
    #[export_name = "get-page-list"]
    unsafe extern "C" fn export_get_page_list(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) -> *mut u8 {
      $($path_to_types)*::_export_get_page_list_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
    #[export_name = "cabi_post_get-page-list"]
    unsafe extern "C" fn _post_return_get_page_list(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_page_list::<$ty>(arg0)
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_prelude_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 72]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 72]);
pub mod midoku {
    pub mod midoku_http {
        #[allow(clippy::all)]
        pub mod http {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum Method {
                Get,
                Post,
                Put,
                Head,
                Delete,
            }
            impl ::core::fmt::Debug for Method {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Method::Get => f.debug_tuple("Method::Get").finish(),
                        Method::Post => f.debug_tuple("Method::Post").finish(),
                        Method::Put => f.debug_tuple("Method::Put").finish(),
                        Method::Head => f.debug_tuple("Method::Head").finish(),
                        Method::Delete => f.debug_tuple("Method::Delete").finish(),
                    }
                }
            }

            impl Method {
                pub(crate) unsafe fn _lift(val: u8) -> Method {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => Method::Get,
                        1 => Method::Post,
                        2 => Method::Put,
                        3 => Method::Head,
                        4 => Method::Delete,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Client {
                handle: _rt::Resource<Client>,
            }

            impl Client {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: _rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl _rt::WasmResource for Client {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[resource-drop]client"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum ResponseError {
                Moved,
            }
            impl ResponseError {
                pub fn name(&self) -> &'static str {
                    match self {
                        ResponseError::Moved => "moved",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ResponseError::Moved => "",
                    }
                }
            }
            impl ::core::fmt::Debug for ResponseError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("ResponseError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ResponseError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), *self as i32)
                }
            }

            impl std::error::Error for ResponseError {}

            impl ResponseError {
                pub(crate) unsafe fn _lift(val: u8) -> ResponseError {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ResponseError::Moved,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Response {
                handle: _rt::Resource<Response>,
            }

            impl Response {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: _rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl _rt::WasmResource for Response {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[resource-drop]response"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl Client {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new() -> Self {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[constructor]client"]
                            fn wit_import() -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import() -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import();
                        Client::from_handle(ret as u32)
                    }
                }
            }
            impl Client {
                #[allow(unused_unsafe, clippy::all)]
                /// Sets the duration to replenish one burst or one cell if not initialized yet.
                pub fn set_rate_limit_period(&self, seconds: u32) -> Result<(), ()> {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]client.set-rate-limit-period"]
                            fn wit_import(_: i32, _: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32, _rt::as_i32(&seconds));
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Client {
                #[allow(unused_unsafe, clippy::all)]
                /// Sets the burst size for the set period or 1 second if not initialized yet.
                pub fn set_rate_limit_burst(&self, burst_size: u32) -> Result<(), ()> {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]client.set-rate-limit-burst"]
                            fn wit_import(_: i32, _: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32, _rt::as_i32(&burst_size));
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Client {
                #[allow(unused_unsafe, clippy::all)]
                /// Makes the HTTP request synchronously.
                pub fn send(
                    &self,
                    method: Method,
                    url: &str,
                    headers: Option<&[(_rt::String, _rt::String)]>,
                    body_bytes: Option<&[u8]>,
                ) -> Result<Response, ()> {
                    unsafe {
                        let mut cleanup_list = _rt::Vec::new();
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                        let vec0 = url;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let (result5_0, result5_1, result5_2) = match headers {
                            Some(e) => {
                                let vec4 = e;
                                let len4 = vec4.len();
                                let layout4 = _rt::alloc::Layout::from_size_align_unchecked(
                                    vec4.len() * 16,
                                    4,
                                );
                                let result4 = if layout4.size() != 0 {
                                    let ptr = _rt::alloc::alloc(layout4).cast::<u8>();
                                    if ptr.is_null() {
                                        _rt::alloc::handle_alloc_error(layout4);
                                    }
                                    ptr
                                } else {
                                    {
                                        ::core::ptr::null_mut()
                                    }
                                };
                                for (i, e) in vec4.into_iter().enumerate() {
                                    let base = result4.add(i * 16);
                                    {
                                        let (t1_0, t1_1) = e;
                                        let vec2 = t1_0;
                                        let ptr2 = vec2.as_ptr().cast::<u8>();
                                        let len2 = vec2.len();
                                        *base.add(4).cast::<usize>() = len2;
                                        *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                        let vec3 = t1_1;
                                        let ptr3 = vec3.as_ptr().cast::<u8>();
                                        let len3 = vec3.len();
                                        *base.add(12).cast::<usize>() = len3;
                                        *base.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                                    }
                                }
                                cleanup_list.extend_from_slice(&[(result4, layout4)]);

                                (1i32, result4, len4)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        let (result7_0, result7_1, result7_2) = match body_bytes {
                            Some(e) => {
                                let vec6 = e;
                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                let len6 = vec6.len();

                                (1i32, ptr6.cast_mut(), len6)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]client.send"]
                            fn wit_import(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        wit_import(
                            (self).handle() as i32,
                            method.clone() as i32,
                            ptr0.cast_mut(),
                            len0,
                            result5_0,
                            result5_1,
                            result5_2,
                            result7_0,
                            result7_1,
                            result7_2,
                            ptr8,
                        );
                        let l9 = i32::from(*ptr8.add(0).cast::<u8>());
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                _rt::alloc::dealloc(ptr.cast(), layout);
                            }
                        }
                        match l9 {
                            0 => {
                                let e = {
                                    let l10 = *ptr8.add(4).cast::<i32>();

                                    Response::from_handle(l10 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Response {
                #[allow(unused_unsafe, clippy::all)]
                pub fn status_code(&self) -> Result<u16, ResponseError> {
                    unsafe {
                        #[repr(align(2))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 4]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4]);
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]response.status-code"]
                            fn wit_import(_: i32, _: *mut u8);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                        match l1 {
                            0 => {
                                let e = {
                                    let l2 = i32::from(*ptr0.add(2).cast::<u16>());

                                    l2 as u16
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());

                                    ResponseError::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Response {
                #[allow(unused_unsafe, clippy::all)]
                /// Consumes the response when called.
                pub fn headers(
                    &self,
                ) -> Result<_rt::Vec<(_rt::String, _rt::String)>, ResponseError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]response.headers"]
                            fn wit_import(_: i32, _: *mut u8);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                        match l1 {
                            0 => {
                                let e = {
                                    let l2 = *ptr0.add(4).cast::<*mut u8>();
                                    let l3 = *ptr0.add(8).cast::<usize>();
                                    let base10 = l2;
                                    let len10 = l3;
                                    let mut result10 = _rt::Vec::with_capacity(len10);
                                    for i in 0..len10 {
                                        let base = base10.add(i * 16);
                                        let e10 = {
                                            let l4 = *base.add(0).cast::<*mut u8>();
                                            let l5 = *base.add(4).cast::<usize>();
                                            let len6 = l5;
                                            let bytes6 =
                                                _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                                            let l7 = *base.add(8).cast::<*mut u8>();
                                            let l8 = *base.add(12).cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 =
                                                _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                                            (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
                                        };
                                        result10.push(e10);
                                    }
                                    _rt::cabi_dealloc(base10, len10 * 16, 4);

                                    result10
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l11 = i32::from(*ptr0.add(4).cast::<u8>());

                                    ResponseError::_lift(l11 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Response {
                #[allow(unused_unsafe, clippy::all)]
                /// Consumes the response when called.
                pub fn bytes(&self) -> Result<_rt::Vec<u8>, ResponseError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "midoku:midoku-http/http")]
                        extern "C" {
                            #[link_name = "[method]response.bytes"]
                            fn wit_import(_: i32, _: *mut u8);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                        match l1 {
                            0 => {
                                let e = {
                                    let l2 = *ptr0.add(4).cast::<*mut u8>();
                                    let l3 = *ptr0.add(8).cast::<usize>();
                                    let len4 = l3;

                                    _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());

                                    ResponseError::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
        }
    }
    pub mod midoku_types {
        #[allow(clippy::all)]
        pub mod chapter {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct Chapter {
                pub id: _rt::String,
                pub title: _rt::String,
                pub volume: f32,
                pub chapter: f32,
                /// The date the chapter was last updated. This is a Unix timestamp in seconds.
                pub data_updated: u32,
                pub scanlator: _rt::String,
                pub url: _rt::String,
                pub language: _rt::String,
            }
            impl ::core::fmt::Debug for Chapter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Chapter")
                        .field("id", &self.id)
                        .field("title", &self.title)
                        .field("volume", &self.volume)
                        .field("chapter", &self.chapter)
                        .field("data-updated", &self.data_updated)
                        .field("scanlator", &self.scanlator)
                        .field("url", &self.url)
                        .field("language", &self.language)
                        .finish()
                }
            }
        }

        #[allow(clippy::all)]
        pub mod manga {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum Status {
                Unknown,
                Ongoing,
                Completed,
                Hiatus,
                Cancelled,
            }
            impl ::core::fmt::Debug for Status {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Status::Unknown => f.debug_tuple("Status::Unknown").finish(),
                        Status::Ongoing => f.debug_tuple("Status::Ongoing").finish(),
                        Status::Completed => f.debug_tuple("Status::Completed").finish(),
                        Status::Hiatus => f.debug_tuple("Status::Hiatus").finish(),
                        Status::Cancelled => f.debug_tuple("Status::Cancelled").finish(),
                    }
                }
            }

            impl Status {
                pub(crate) unsafe fn _lift(val: u8) -> Status {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => Status::Unknown,
                        1 => Status::Ongoing,
                        2 => Status::Completed,
                        3 => Status::Hiatus,
                        4 => Status::Cancelled,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum ContentRating {
                Safe,
                Suggestive,
                Nsfw,
            }
            impl ::core::fmt::Debug for ContentRating {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        ContentRating::Safe => f.debug_tuple("ContentRating::Safe").finish(),
                        ContentRating::Suggestive => {
                            f.debug_tuple("ContentRating::Suggestive").finish()
                        }
                        ContentRating::Nsfw => f.debug_tuple("ContentRating::Nsfw").finish(),
                    }
                }
            }

            impl ContentRating {
                pub(crate) unsafe fn _lift(val: u8) -> ContentRating {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ContentRating::Safe,
                        1 => ContentRating::Suggestive,
                        2 => ContentRating::Nsfw,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum ReadingMode {
                RightToLeft,
                LeftToRight,
                Vertical,
                Scroll,
            }
            impl ::core::fmt::Debug for ReadingMode {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        ReadingMode::RightToLeft => {
                            f.debug_tuple("ReadingMode::RightToLeft").finish()
                        }
                        ReadingMode::LeftToRight => {
                            f.debug_tuple("ReadingMode::LeftToRight").finish()
                        }
                        ReadingMode::Vertical => f.debug_tuple("ReadingMode::Vertical").finish(),
                        ReadingMode::Scroll => f.debug_tuple("ReadingMode::Scroll").finish(),
                    }
                }
            }

            impl ReadingMode {
                pub(crate) unsafe fn _lift(val: u8) -> ReadingMode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => ReadingMode::RightToLeft,
                        1 => ReadingMode::LeftToRight,
                        2 => ReadingMode::Vertical,
                        3 => ReadingMode::Scroll,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone)]
            pub struct Manga {
                pub id: _rt::String,
                pub title: _rt::String,
                pub url: _rt::String,
                pub description: _rt::String,
                pub cover_url: _rt::String,
                pub author_name: _rt::String,
                pub artist_name: _rt::String,
                pub categories: _rt::Vec<_rt::String>,
                pub status: Status,
                pub content_rating: ContentRating,
                pub reading_mode: ReadingMode,
            }
            impl ::core::fmt::Debug for Manga {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Manga")
                        .field("id", &self.id)
                        .field("title", &self.title)
                        .field("url", &self.url)
                        .field("description", &self.description)
                        .field("cover-url", &self.cover_url)
                        .field("author-name", &self.author_name)
                        .field("artist-name", &self.artist_name)
                        .field("categories", &self.categories)
                        .field("status", &self.status)
                        .field("content-rating", &self.content_rating)
                        .field("reading-mode", &self.reading_mode)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct PageResult {
                pub page: _rt::Vec<Manga>,
                pub has_more: bool,
            }
            impl ::core::fmt::Debug for PageResult {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("PageResult")
                        .field("page", &self.page)
                        .field("has-more", &self.has_more)
                        .finish()
                }
            }
        }

        #[allow(clippy::all)]
        pub mod page {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct Page {
                pub index: u32,
                pub url: _rt::String,
                /// The base64-encoded data of the page.
                pub bas64: _rt::String,
            }
            impl ::core::fmt::Debug for Page {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Page")
                        .field("index", &self.index)
                        .field("url", &self.url)
                        .field("bas64", &self.bas64)
                        .finish()
                }
            }
        }
    }
}
mod _rt {

    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        // NB: This would ideally be `u32` but it is not. The fact that this has
        // interior mutability is not exposed in the API of this type except for the
        // `take_handle` method which is supposed to in theory be private.
        //
        // This represents, almost all the time, a valid handle value. When it's
        // invalid it's stored as `u32::MAX`.
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }

    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }

    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }

        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }

        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }

    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource")
                .field("handle", &self.handle)
                .finish()
        }
    }

    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    // If this handle was "taken" then don't do anything in the
                    // destructor.
                    u32::MAX => {}

                    // ... but otherwise do actually destroy it with the imported
                    // component model intrinsic as defined through `T`.
                    other => T::drop(other),
                }
            }
        }
    }

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }

    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }

    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }

    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }

    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_prelude_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_prelude_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_prelude_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:prelude:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1517] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xef\x0a\x01A\x02\x01\
A\x1e\x01B\"\x01m\x05\x03get\x04post\x03put\x04head\x06delete\x04\0\x06method\x03\
\0\0\x04\0\x06client\x03\x01\x01m\x01\x05moved\x04\0\x0eresponse-error\x03\0\x03\
\x04\0\x08response\x03\x01\x01i\x02\x01@\0\0\x06\x04\0\x13[constructor]client\x01\
\x07\x01h\x02\x01j\0\0\x01@\x02\x04self\x08\x07secondsy\0\x09\x04\0$[method]clie\
nt.set-rate-limit-period\x01\x0a\x01@\x02\x04self\x08\x0aburst-sizey\0\x09\x04\0\
#[method]client.set-rate-limit-burst\x01\x0b\x01o\x02ss\x01p\x0c\x01k\x0d\x01p}\x01\
k\x0f\x01i\x05\x01j\x01\x11\0\x01@\x05\x04self\x08\x06method\x01\x03urls\x07head\
ers\x0e\x0abody-bytes\x10\0\x12\x04\0\x13[method]client.send\x01\x13\x01h\x05\x01\
j\x01{\x01\x04\x01@\x01\x04self\x14\0\x15\x04\0\x1c[method]response.status-code\x01\
\x16\x01j\x01\x0d\x01\x04\x01@\x01\x04self\x14\0\x17\x04\0\x18[method]response.h\
eaders\x01\x18\x01j\x01\x0f\x01\x04\x01@\x01\x04self\x14\0\x19\x04\0\x16[method]\
response.bytes\x01\x1a\x03\x01\x17midoku:midoku-http/http\x05\0\x01B\x02\x01r\x08\
\x02ids\x05titles\x06volumev\x07chapterv\x0cdata-updatedy\x09scanlators\x03urls\x08\
languages\x04\0\x07chapter\x03\0\0\x03\x01\x1bmidoku:midoku-types/chapter\x05\x01\
\x01B\x0c\x01m\x05\x07unknown\x07ongoing\x09completed\x06hiatus\x09cancelled\x04\
\0\x06status\x03\0\0\x01m\x03\x04safe\x0asuggestive\x04nsfw\x04\0\x0econtent-rat\
ing\x03\0\x02\x01m\x04\x0dright-to-left\x0dleft-to-right\x08vertical\x06scroll\x04\
\0\x0creading-mode\x03\0\x04\x01ps\x01r\x0b\x02ids\x05titles\x03urls\x0bdescript\
ions\x09cover-urls\x0bauthor-names\x0bartist-names\x0acategories\x06\x06status\x01\
\x0econtent-rating\x03\x0creading-mode\x05\x04\0\x05manga\x03\0\x07\x01p\x08\x01\
r\x02\x04page\x09\x08has-more\x7f\x04\0\x0bpage-result\x03\0\x0a\x03\x01\x19mido\
ku:midoku-types/manga\x05\x02\x01B\x02\x01r\x03\x05indexy\x03urls\x05bas64s\x04\0\
\x04page\x03\0\0\x03\x01\x18midoku:midoku-types/page\x05\x03\x02\x03\0\x01\x07ch\
apter\x03\0\x07chapter\x03\0\x04\x02\x03\0\x02\x05manga\x03\0\x05manga\x03\0\x06\
\x02\x03\0\x02\x0bpage-result\x03\0\x0bpage-result\x03\0\x08\x02\x03\0\x03\x04pa\
ge\x03\0\x04page\x03\0\x0a\x01j\x01\x09\0\x01@\x01\x04pagey\0\x0c\x04\0\x0eget-m\
anga-list\x01\x0d\x01j\x01\x07\0\x01@\x01\x08manga-ids\0\x0e\x04\0\x11get-manga-\
details\x01\x0f\x01p\x05\x01j\x01\x10\0\x01@\x01\x08manga-ids\0\x11\x04\0\x10get\
-chapter-list\x01\x12\x01p\x0b\x01j\x01\x13\0\x01@\x02\x08manga-ids\x0achapter-i\
ds\0\x14\x04\0\x0dget-page-list\x01\x15\x04\x01\x1dmidoku:example-source/prelude\
\x04\0\x0b\x0d\x01\0\x07prelude\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
wit-component\x070.201.0\x10wit-bindgen-rust\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
